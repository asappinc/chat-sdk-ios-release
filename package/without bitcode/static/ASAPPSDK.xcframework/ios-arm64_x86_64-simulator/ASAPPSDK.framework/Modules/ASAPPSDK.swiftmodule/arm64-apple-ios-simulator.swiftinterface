// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ASAPPSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import ASAPPSDK
import AVFoundation
import AVKit
import Accelerate
import AudioToolbox
import CarPlay
import Combine
import CommonCrypto
import Compression
import CoreGraphics
import CoreImage
import CryptoKit
import Foundation
import ImageIO
import MobileCoreServices
import Photos
import PhotosUI
import SafariServices
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import UserNotifications
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum ThemeBannerStyle {
  case success
  case warning
  case failure
  public static func == (a: ASAPPSDK.ThemeBannerStyle, b: ASAPPSDK.ThemeBannerStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct BannerViewData {
  public var bgColor: UIKit.UIColor
  public var labelTextColor: UIKit.UIColor
  public var labelFont: UIKit.UIFont
  public var iconImage: UIKit.UIImage
  public var iconImageSize: CoreFoundation.CGSize
  public var bannerStyle: ASAPPSDK.ThemeBannerStyle
  public init(bgColor: UIKit.UIColor, labelTextColor: UIKit.UIColor, labelFont: UIKit.UIFont, iconImage: UIKit.UIImage, iconImageSize: CoreFoundation.CGSize, bannerStyle: ASAPPSDK.ThemeBannerStyle)
}
@objc(ASAPPBanner) @objcMembers public class ASAPPBanner : ObjectiveC.NSObject {
  public init(bannerViewDataArray: [ASAPPSDK.BannerViewData])
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPViews) @objcMembers public class ASAPPViews : ObjectiveC.NSObject {
  @objc public var chatTitle: UIKit.UIView?
  public var customViewStyle: ASAPPSDK.ASAPPCustomViewStyles?
  @objc override dynamic public init()
  @objc deinit
}
infix operator ←→ : DefaultPrecedence
@objc(ASAPPCustomImage) @objcMembers public class ASAPPCustomImage : ObjectiveC.NSObject {
  @objc public var image: UIKit.UIImage
  @objc public var size: CoreFoundation.CGSize
  @objc public var insets: UIKit.UIEdgeInsets
  @objc public init(image: UIKit.UIImage, size: CoreFoundation.CGSize, insets: UIKit.UIEdgeInsets = UIEdgeInsets(top: 4, left: 0, bottom: 4, right: 0))
  @objc deinit
}
@objc(ASAPPInputColors) @objcMembers public class ASAPPInputColors : ObjectiveC.NSObject {
  @objc public var background: UIKit.UIColor
  @objc public var text: UIKit.UIColor
  @objc public var placeholderText: UIKit.UIColor
  @objc public var tint: UIKit.UIColor
  @objc public var border: UIKit.UIColor?
  @objc public var primaryButton: UIKit.UIColor
  @objc public var secondaryButton: UIKit.UIColor
  @objc public init(background: UIKit.UIColor, text: UIKit.UIColor, placeholderText: UIKit.UIColor, tint: UIKit.UIColor, border: UIKit.UIColor?, primaryButton: UIKit.UIColor, secondaryButton: UIKit.UIColor)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ObserverCollection<T> where T : AnyObject {
  public func addObserver(_ observer: T)
  public func removeObserver(_ observer: T?)
  public func toArray() -> [T?]
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPNavBarStyles) @objcMembers public class ASAPPNavBarStyles : ObjectiveC.NSObject {
  @objc public var buttonImages: ASAPPSDK.ASAPPNavBarButtonImages
  @objc public var titlePadding: UIKit.UIEdgeInsets
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ASAPPChannel : Swift.Int {
  case chat
  case phone
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc(ASAPPTextStyles) @objcMembers public class ASAPPTextStyles : ObjectiveC.NSObject {
  @objc public var navButton: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var button: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var actionButton: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var link: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var header1: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var header2: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var header3: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var subheader: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var body: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var bodyBold: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var body2: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var bodyBold2: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var detail1: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var detail2: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public var error: ASAPPSDK.ASAPPTextStyle {
    @objc get
    @objc set
  }
  @objc public func updateStyles(for fontFamily: ASAPPSDK.ASAPPFontFamily)
  @objc public func updateColors(with color: UIKit.UIColor)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPFontFamily) @objcMembers public class ASAPPFontFamily : ObjectiveC.NSObject {
  @objc final public let light: UIKit.UIFont
  @objc final public let regular: UIKit.UIFont
  @objc final public let medium: UIKit.UIFont
  @objc final public let bold: UIKit.UIFont
  @objc public init(light: UIKit.UIFont, regular: UIKit.UIFont, medium: UIKit.UIFont, bold: UIKit.UIFont)
  @objc public init?(lightFontName: Swift.String, regularFontName: Swift.String, mediumFontName: Swift.String, boldFontName: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPStyles) @objcMembers public class ASAPPStyles : ObjectiveC.NSObject {
  @objc public var textStyles: ASAPPSDK.ASAPPTextStyles
  @objc public var colors: ASAPPSDK.ASAPPColors
  @objc public var navBarStyles: ASAPPSDK.ASAPPNavBarStyles
  @objc public var primaryButtonRoundingStyle: ASAPPSDK.ASAPPPrimaryButtonRoundingStyle {
    @objc get
    @objc set
  }
  @objc public var allowedOrientations: ASAPPSDK.ASAPPAllowedOrientations
  @objc public var isDarkModeAllowed: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ASAPPAllowedOrientations : Swift.Int, Swift.CaseIterable {
  case portraitLocked
  case iPadLandscapeAllowed
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [ASAPPSDK.ASAPPAllowedOrientations]
  public typealias RawValue = Swift.Int
  public static var allCases: [ASAPPSDK.ASAPPAllowedOrientations] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public typealias ASAPPRequestContextProvider = ((_ needsRefresh: Swift.Bool) -> [Swift.String : Any])
@objc(ASAPPUser) @objcMembers public class ASAPPUser : ObjectiveC.NSObject {
  @objc final public let isAnonymous: Swift.Bool
  @objc final public let userIdentifier: Swift.String
  @objc final public let requestContextProvider: ASAPPSDK.ASAPPRequestContextProvider
  @objc public init(userIdentifier: Swift.String?, requestContextProvider: @escaping ASAPPSDK.ASAPPRequestContextProvider)
  @objc deinit
}
@objc public enum ASAPPError : Swift.Int {
  case getChatStatusFailed
  case pushDeregistrationFailed
  case authenticationFailed
  case openChannelFailed
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(ASAPPTextStyle) @objcMembers public class ASAPPTextStyle : ObjectiveC.NSObject {
  @objc(ASAPPCaseStyle) public enum ASAPPCaseStyle : Swift.Int {
    case upper
    case start
    case original
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public init(font: UIKit.UIFont, size: CoreFoundation.CGFloat, letterSpacing: CoreFoundation.CGFloat, color: UIKit.UIColor, case: ASAPPSDK.ASAPPTextStyle.ASAPPCaseStyle = .original)
  @objc deinit
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
@objc public enum ASAPPLogLevel : Swift.Int {
  case none = 0
  case errors = 1
  case warning = 2
  case debug = 3
  case info = 4
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class ComponentViewController : ASAPPSDK.ASAPPViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
}
public enum ButtonWidthType : CoreFoundation.CGFloat {
  case wrapContent
  case matchParent
  case custom
  public init?(rawValue: CoreFoundation.CGFloat)
  public typealias RawValue = CoreFoundation.CGFloat
  public var rawValue: CoreFoundation.CGFloat {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(ASAPPViewController) @_Concurrency.MainActor(unsafe) public class ASAPPViewController : UIKit.UIViewController {
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMove(toParent parent: UIKit.UIViewController?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
}
extension ASAPPSDK.ASAPPViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarUpdateAnimation: UIKit.UIStatusBarAnimation {
    @objc get
  }
}
extension ASAPPSDK.ASAPPViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
}

@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
public class ASAPPCustomViewStyles {
  public struct TitleBar {
    public var container: ASAPPSDK.OptionalViewTypeConfig
    public var actionBackButton: ASAPPSDK.OptionalButtonTypeConfig
    public var actionMoreButton: ASAPPSDK.OptionalButtonTypeConfig
    public var primaryText: ASAPPSDK.OptionalTextTypeConfig
    public var icon: ASAPPSDK.OptionalImageViewTypeConfig
  }
  public struct ChatComposerBar {
    public var container: ASAPPSDK.OptionalViewTypeConfig
    public var btnSend: ASAPPSDK.OptionalButtonTypeConfig
  }
  public struct EWTBarViewGroup {
    public var container: ASAPPSDK.OptionalViewTypeConfig
    public var progressBar: ASAPPSDK.OptionalProgressBarTypeConfig
    public var txtEwtTitle: ASAPPSDK.OptionalTextTypeConfig
    public var txtEwtValue: ASAPPSDK.OptionalTextTypeConfig
    public var btnLeave: ASAPPSDK.OptionalButtonTypeConfig
  }
  public struct QuickRepliesViewGroup {
    public var container: ASAPPSDK.OptionalViewTypeConfig
  }
  public struct RestartButtonBar {
    public var primaryText: ASAPPSDK.OptionalButtonTypeConfig?
    public var icon: ASAPPSDK.OptionalImageViewTypeConfig?
  }
  public struct ConnectionBar {
  }
  public var maxQuickReplyViewHeight: Swift.Double?
  public var titleBar: ASAPPSDK.ASAPPCustomViewStyles.TitleBar
  public var connectionBar: ASAPPSDK.ConnectionBarGroup
  public var ewtBar: ASAPPSDK.ASAPPCustomViewStyles.EWTBarViewGroup
  public var chatComposerBar: ASAPPSDK.ASAPPCustomViewStyles.ChatComposerBar
  public var bottomSheetConfirmationDialog: ASAPPSDK.BottomSheetConfirmDialog
  public var quickRepliesViewGroup: ASAPPSDK.ASAPPCustomViewStyles.QuickRepliesViewGroup
  public var restartButtonBar: ASAPPSDK.ASAPPCustomViewStyles.RestartButtonBar
  public init()
  @objc deinit
}
public class ConnectionBarGroup {
  public var success: ASAPPSDK.ConnectionBar
  public var warn: ASAPPSDK.ConnectionBar
  public var error: ASAPPSDK.ConnectionBar
  public init()
  @objc deinit
}
public struct ConnectionBar {
  public init(container: ASAPPSDK.OptionalViewTypeConfig, primaryText: ASAPPSDK.OptionalTextTypeConfig, icon: ASAPPSDK.OptionalImageViewTypeConfig)
}
public struct ButtonProgressContainer {
  public var button: ASAPPSDK.OptionalButtonTypeConfig
}
public class BottomSheetConfirmDialog {
  public var confirmButtonBar: ASAPPSDK.ButtonProgressContainer
  public var cancelButtonBar: ASAPPSDK.ButtonProgressContainer
  public var title: ASAPPSDK.OptionalTextTypeConfig
  public var bodyText: ASAPPSDK.OptionalTextTypeConfig
  public init(container: ASAPPSDK.OptionalViewTypeConfig, confirmButtonBar: ASAPPSDK.ButtonProgressContainer, cancelButtonBar: ASAPPSDK.ButtonProgressContainer, title: ASAPPSDK.OptionalTextTypeConfig, bodyText: ASAPPSDK.OptionalTextTypeConfig, errorText: ASAPPSDK.OptionalTextTypeConfig)
  @objc deinit
}
public enum FeedbackType {
  case success
  case warning
  case error
  public var iconResource: UIKit.UIImage? {
    get
  }
  public func getTextColor() -> UIKit.UIColor
  public func getBackgroundColor() -> UIKit.UIColor
  public static func == (a: ASAPPSDK.FeedbackType, b: ASAPPSDK.FeedbackType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class OptionalButtonTypeConfig : ASAPPSDK.OptionalViewTypeConfig {
  public init(tintColorNormal: UIKit.UIColor? = nil, typeface: UIKit.UIFont? = nil, textColorNormal: UIKit.UIColor? = nil, textColorHighlighted: UIKit.UIColor? = nil, width: CoreFoundation.CGFloat? = nil, margin: CoreFoundation.CGFloat? = nil)
  @objc deinit
}
public class OptionalTextTypeConfig {
  public init(typeface: UIKit.UIFont? = nil, letterSpacing: CoreFoundation.CGFloat? = nil, color: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil)
  @objc deinit
}
public class OptionalImageViewTypeConfig : ASAPPSDK.OptionalViewTypeConfig {
  public init(width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, maxHeight: CoreFoundation.CGFloat? = nil, margin: CoreFoundation.CGFloat? = nil, padding: CoreFoundation.CGFloat? = nil, src: UIKit.UIImage? = nil, tintColor: UIKit.UIColor? = nil, backgroundColor: UIKit.UIColor? = nil, isVisible: Swift.Bool? = true)
  @objc deinit
}
public class OptionalProgressBarTypeConfig : ASAPPSDK.OptionalViewTypeConfig {
  public init(width: CoreFoundation.CGFloat? = nil, margin: CoreFoundation.CGFloat? = nil, padding: CoreFoundation.CGFloat? = nil, isVisible: Swift.Bool? = nil, backgroundColor: UIKit.UIColor? = nil, progressColor: UIKit.UIColor? = nil)
  @objc deinit
}
public class OptionalViewTypeConfig {
  public init(width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, maxHeight: CoreFoundation.CGFloat? = nil, margin: CoreFoundation.CGFloat? = nil, padding: CoreFoundation.CGFloat? = nil, radius: CoreFoundation.CGFloat? = nil, isVisible: Swift.Bool? = nil, backgroundColor: UIKit.UIColor? = nil)
  @objc deinit
}
@objc public protocol ASAPPDelegate {
  @objc func chatViewControllerDidTapUserLoginButton()
  @objc func chatViewControllerDidDisappear()
  @objc func chatViewControllerDidTapDeepLink(name: Swift.String, data: [Swift.String : Any]?)
  @objc func chatViewControllerShouldHandleWebLink(url: Foundation.URL) -> Swift.Bool
  @objc func chatViewControllerDidReceiveChatEvent(name: Swift.String, data: [Swift.String : Any]?)
  @objc optional func chatViewControllerDidReceiveEndChatEvent(eventData: [Swift.String : Any]?)
}
@_inheritsConvenienceInitializers @objc(ASAPP) @objcMembers public class ASAPP : ObjectiveC.NSObject {
  @objc public static var clientVersion: Swift.String {
    @objc get
  }
  @objc weak public static var delegate: (any ASAPPSDK.ASAPPDelegate)?
  @objc public static var config: ASAPPSDK.ASAPPConfig! {
    get
  }
  @objc public static var user: ASAPPSDK.ASAPPUser! {
    @objc get
    @objc set
  }
  @objc public static var styles: ASAPPSDK.ASAPPStyles
  @objc public static var strings: ASAPPSDK.ASAPPStrings
  @objc public static var views: ASAPPSDK.ASAPPViews
  @objc public var bannerViews: ASAPPSDK.ASAPPBanner?
  @objc public static var debugLogLevel: ASAPPSDK.ASAPPLogLevel
  @objc public class func initialize(with config: ASAPPSDK.ASAPPConfig)
  @objc public class func createChatViewControllerForPushing(fromNotificationWith userInfo: [Swift.AnyHashable : Any]?, themeData: ASAPPSDK.ASAPP? = nil) -> UIKit.UIViewController?
  @objc public class func createChatViewControllerForPushing(withIntent intent: [Swift.String : Any]) -> UIKit.UIViewController?
  @objc public class func createChatViewControllerForPresenting(fromNotificationWith userInfo: [Swift.AnyHashable : Any]?) -> UIKit.UIViewController?
  @objc public class func createChatViewControllerForPresenting(withIntent intent: [Swift.String : Any]) -> UIKit.UIViewController?
  @objc public class func createChatViewControllerForPresentingFromChatInstead() -> UIKit.UIViewController?
  @objc public class func createChatViewControllerForPushingFromChatInstead() -> UIKit.UIViewController?
  @nonobjc public static var shouldRequestCameraAuthorization: Swift.Bool?
  @objc public static var objcShouldRequestCameraAuthorization: Foundation.NSNumber?
  @nonobjc public static var shouldRequestPhotoLibraryAuthorization: Swift.Bool?
  @objc public static var objcShouldRequestPhotoLibraryAuthorization: Foundation.NSNumber?
  @objc public static var shouldRequestNotificationAuthorization: Swift.Bool
  @objc public static var notificationAuthorizationDenied: (() -> Swift.Void)?
  @objc public class func enablePushNotifications(with deviceToken: Foundation.Data)
  @objc(enablePushNotificationsWithUUID:) public class func enablePushNotifications(with uuid: Swift.String)
  @objc public class func disablePushNotifications(failure: @escaping ASAPPSDK.ASAPP.FailureHandler)
  @objc public class func skipToBottom()
  @objc public class func updateCustomerDataInfo(customerParams: [Swift.String : Any])
  public typealias ChatStatusHandler = ((_ unread: Swift.Int, _ isLiveChat: Swift.Bool) -> Swift.Void)
  public typealias FailureHandler = ((_ error: ASAPPSDK.ASAPPError) -> Swift.Void)
  @objc public class func getChatStatus(success: @escaping ASAPPSDK.ASAPP.ChatStatusHandler, failure: @escaping ASAPPSDK.ASAPP.FailureHandler)
  @objc public class func canHandleNotification(with userInfo: [Swift.AnyHashable : Any]?) -> Swift.Bool
  @objc public class func clearSavedSession()
  @objc public static func setIntent(_ data: [Swift.String : Any])
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPColors) @objcMembers public class ASAPPColors : ObjectiveC.NSObject {
  @objc public var primary: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var onPrimary: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var onBackground: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var navBarBackground: UIKit.UIColor?
  @objc public var navBarTitle: UIKit.UIColor
  @objc public var navBarButton: UIKit.UIColor
  @objc public var navBarButtonActive: UIKit.UIColor
  @objc public var background: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var separatorPrimary: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var separatorSecondary: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var controlTint: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var controlSecondary: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var controlBackground: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var success: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var warning: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var failure: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc public var textButtonPrimary: ASAPPSDK.ASAPPButtonColors {
    @objc get
    @objc set
  }
  @objc public var buttonPrimary: ASAPPSDK.ASAPPButtonColors {
    @objc get
    @objc set
  }
  @objc public var buttonSecondary: ASAPPSDK.ASAPPButtonColors {
    @objc get
    @objc set
  }
  @objc public var messagesListBackground: UIKit.UIColor
  @objc public var messageText: UIKit.UIColor
  @objc public var messageBackground: UIKit.UIColor
  @objc public var messageBorder: UIKit.UIColor?
  @objc public var replyMessageText: UIKit.UIColor
  @objc public var replyMessageBackground: UIKit.UIColor
  @objc public var replyMessageBorder: UIKit.UIColor
  @objc public var quickReplyButton: ASAPPSDK.ASAPPButtonColors
  @objc public var actionButton: ASAPPSDK.ASAPPButtonColors
  @objc public var chatInput: ASAPPSDK.ASAPPInputColors
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(ASAPPStrings) @objcMembers public class ASAPPStrings : ObjectiveC.NSObject {
  @objc public var accessibilityClose: Swift.String
  @objc public var accessibilityMore: Swift.String
  @objc public var accessibilitySend: Swift.String
  @objc public var connectionBannerConnected: Swift.String
  @objc public var connectionBannerConnecting: Swift.String
  @objc public var connectionBannerConnectingWhenSending: Swift.String
  @objc public var connectionBannerDisconnected: Swift.String
  @objc public var connectionBannerNotConnectedWhenSending: Swift.String
  @objc public var connectionBannerFailedToSend: Swift.String
  @objc public var connectionBannerMessageTooLong: Swift.String
  @objc public var chatTitle: Swift.String?
  @objc public var endChatTitle: Swift.String
  @objc public var chatInputPlaceholder: Swift.String
  @objc public var quickRepliesRestartButton: Swift.String
  @objc public var inlineFormFailedToLoad: Swift.String
  @objc public var secureScreenCoverText: Swift.String
  @objc public var requestErrorGenericFailureTitle: Swift.String
  @objc public var requestErrorGenericFailure: Swift.String
  @objc public var messageFailedToSend: Swift.String
  @objc public var alertDismissButton: Swift.String
  @objc public var failureToLoadScreen: Swift.String
  @objc public var failureToLoadScreenReloadButton: Swift.String
  @objc public var failureToLoadScreenCloseButton: Swift.String
  @objc public var requiredFieldEmptyMessage: Swift.String
  @objc public var requiredFieldsEmptyErrorMessage: Swift.String
  @objc public var restartConfirmationTitle: Swift.String
  @objc public var restartConfirmationBody: Swift.String
  @objc public var restartConfirmationRestartButton: Swift.String
  @objc public var restartConfirmationHideButton: Swift.String
  @objc public var modalViewCancelButton: Swift.String
  @objc public var modalViewSubmitButton: Swift.String
  @objc public var modalViewDoneButton: Swift.String
  @objc public var mediaPermissionsErrorTitle: Swift.String
  @objc public var mediaPermissionsErrorMessage: Swift.String
  @objc public var mediaPermissionsErrorCancelButton: Swift.String
  @objc public var mediaPermissionsErrorSettingsButton: Swift.String
  @objc public var accessibilityCloseChatInstead: Swift.String
  @objc public var leaveQueueConfirmationTitle: Swift.String
  @objc public var leaveQueueConfirmationBodyTitle: Swift.String
  @objc public var leaveQueueConfirmationButton: Swift.String
  @objc public var leaveQueueConfirmationHideButton: Swift.String
  @objc public var callInProgressBody: Swift.String
  @objc public var viewImage: Swift.String
  @objc public var downloadPDF: Swift.String
  @objc public var fileSizeExceedErrorAlert: Swift.String
  @objc public var unsupportedFileErrorAlert: Swift.String
  @objc public var fileUploadedSuccessfullMessage: Swift.String
  @objc public var errorInUploadingMessage: Swift.String
  @objc public var errorInViewingFile: Swift.String
  @objc public var errorMessageInSendPictureMessageAPI: Swift.String
  @objc public var unsupportedFile: Swift.String
  @objc public var fetchingFileMesage: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(ASAPPPrimaryButtonRoundingStyle) @objcMembers public class ASAPPPrimaryButtonRoundingStyle : ObjectiveC.NSObject {
  @objc public static var pill: ASAPPSDK.ASAPPPrimaryButtonRoundingStyle
  @objc public static func radius(_ value: Swift.Int) -> ASAPPSDK.ASAPPPrimaryButtonRoundingStyle
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(ASAPPChatInsteadViewController) @_Concurrency.MainActor(unsafe) public class ASAPPChatInsteadViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var modalPresentationStyle: UIKit.UIModalPresentationStyle {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public init(phoneNumber: Swift.String, delegate: any ASAPPSDK.ASAPPChannelDelegate, title: Swift.String? = nil, chatIcon: UIKit.UIImage? = nil)
  @objc @_Concurrency.MainActor(unsafe) public init(phoneNumber: Swift.String, delegate: any ASAPPSDK.ASAPPChannelDelegate, title: Foundation.NSString?, chatIcon: UIKit.UIImage? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc deinit
}
extension ASAPPSDK.ASAPPChatInsteadViewController : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate, UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, referenceSizeForHeaderInSection section: Swift.Int) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
}
extension ASAPPSDK.ASAPPChatInsteadViewController : UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
}
extension ASAPPSDK.ASAPPChatInsteadViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
}
public struct FormatIndicatedCacheSerializer : ASAPPSDK.CacheSerializer {
  public static let png: ASAPPSDK.FormatIndicatedCacheSerializer
  public static let jpeg: ASAPPSDK.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> ASAPPSDK.FormatIndicatedCacheSerializer
  public static let gif: ASAPPSDK.FormatIndicatedCacheSerializer
  public func data(with image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
@available(iOS 14.0, *)
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : CarPlay.CPListItem {
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : CarPlay.CPListItem {
  @_Concurrency.MainActor public var taskIdentifier: ASAPPSDK.Source.Identifier.Value? {
    get
  }
}
public struct ImageCreatingOptions : Swift.Equatable {
  public var scale: CoreFoundation.CGFloat
  public var duration: Foundation.TimeInterval
  public var preloadAll: Swift.Bool
  public var onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
  public static func == (a: ASAPPSDK.ImageCreatingOptions, b: ASAPPSDK.ImageCreatingOptions) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
public protocol ImageFrameSource {
  var data: Foundation.Data? { get }
  var frameCount: Swift.Int { get }
  func frame(at index: Swift.Int, maxSize: CoreFoundation.CGSize?) -> CoreGraphics.CGImage?
  func duration(at index: Swift.Int) -> Foundation.TimeInterval
  func copy() -> Self
}
extension ASAPPSDK.ImageFrameSource {
  public func frame(at index: Swift.Int) -> CoreGraphics.CGImage?
  public func copy() -> Self
}
public protocol KingfisherImageSettable : ASAPPSDK.KingfisherCompatible {
  @_Concurrency.MainActor func setImage(_ image: ASAPPSDK.KFCrossPlatformImage?, options: ASAPPSDK.KingfisherParsedOptionsInfo)
  @_Concurrency.MainActor func getImage() -> ASAPPSDK.KFCrossPlatformImage?
}
public protocol KingfisherHasImageComponent : ASAPPSDK.KingfisherImageSettable {
  @_Concurrency.MainActor var image: ASAPPSDK.KFCrossPlatformImage? { get set }
}
extension ASAPPSDK.KingfisherHasImageComponent {
  @_Concurrency.MainActor public func setImage(_ image: ASAPPSDK.KFCrossPlatformImage?, options: ASAPPSDK.KingfisherParsedOptionsInfo)
  @_Concurrency.MainActor public func getImage() -> ASAPPSDK.KFCrossPlatformImage?
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UIAction : ASAPPSDK.KingfisherHasImageComponent {
}
@available(iOS 13.0, tvOS 13.0, *)
extension UIKit.UICommand : ASAPPSDK.KingfisherHasImageComponent {
}
extension UIKit.UIBarItem : ASAPPSDK.KingfisherHasImageComponent {
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : ASAPPSDK.KingfisherImageSettable {
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any ASAPPSDK.ImageDataProvider)?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any ASAPPSDK.ImageDataProvider)?, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : ASAPPSDK.KingfisherImageSettable {
  @_Concurrency.MainActor public var taskIdentifier: ASAPPSDK.Source.Identifier.Value? {
    get
  }
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, attributedView: @autoclosure @escaping @Sendable () -> ASAPPSDK.KFCrossPlatformView, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, attributedView: @autoclosure @escaping @Sendable () -> ASAPPSDK.KFCrossPlatformView, placeholder: ASAPPSDK.KFCrossPlatformImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @_Concurrency.MainActor public var taskIdentifier: ASAPPSDK.Source.Identifier.Value? {
    get
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public struct KFImage : ASAPPSDK.KFImageProtocol {
  @_Concurrency.MainActor public var context: ASAPPSDK.KFImage.Context<SwiftUI.Image>
  @_Concurrency.MainActor public init(context: ASAPPSDK.KFImage.Context<SwiftUI.Image>)
  public typealias Body = @_opaqueReturnTypeOf("$s8ASAPPSDK15KFImageProtocolPAAE4bodyQrvp", 0) __<ASAPPSDK.KFImage>
  public typealias HoldingView = SwiftUI.Image
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUI.Image : ASAPPSDK.KFImageHoldingView {
  public typealias RenderingView = SwiftUI.Image
  @_Concurrency.MainActor public static func created(from image: ASAPPSDK.KFCrossPlatformImage?, context: ASAPPSDK.KFImage.Context<SwiftUI.Image>) -> SwiftUI.Image
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImage {
  @_Concurrency.MainActor public func resizable(capInsets: SwiftUI.EdgeInsets = EdgeInsets(), resizingMode: SwiftUI.Image.ResizingMode = .stretch) -> ASAPPSDK.KFImage
  @_Concurrency.MainActor public func renderingMode(_ renderingMode: SwiftUI.Image.TemplateRenderingMode?) -> ASAPPSDK.KFImage
  @_Concurrency.MainActor public func interpolation(_ interpolation: SwiftUI.Image.Interpolation) -> ASAPPSDK.KFImage
  @_Concurrency.MainActor public func antialiased(_ isAntialiased: Swift.Bool) -> ASAPPSDK.KFImage
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  @_Concurrency.MainActor public func loadImmediately(_ start: Swift.Bool = true) -> ASAPPSDK.KFImage
}
public typealias DownloadProgressBlock = ((_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult : Swift.Sendable {
  public let image: ASAPPSDK.KFCrossPlatformImage
  public let cacheType: ASAPPSDK.CacheType
  public let source: ASAPPSDK.Source
  public let originalSource: ASAPPSDK.Source
  public let data: @Sendable () -> Foundation.Data?
}
public struct PropagationError : Swift.Sendable {
  public let source: ASAPPSDK.Source
  public let error: ASAPPSDK.KingfisherError
}
#if compiler(>=5.3) && $Sendable
public typealias DownloadTaskUpdatedBlock = (@Sendable (_ newTask: ASAPPSDK.DownloadTask?) -> Swift.Void)
#endif
public class KingfisherManager : @unchecked Swift.Sendable {
  public static let shared: ASAPPSDK.KingfisherManager
  public var cache: ASAPPSDK.ImageCache {
    get
    set
  }
  public var downloader: ASAPPSDK.ImageDownloader {
    get
    set
  }
  public var defaultOptions: ASAPPSDK.KingfisherOptionsInfo
  public init(downloader: ASAPPSDK.ImageDownloader, cache: ASAPPSDK.ImageCache)
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  public func retrieveImage(with resource: any ASAPPSDK.Resource, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, downloadTaskUpdated: ASAPPSDK.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)?) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  public func retrieveImage(with source: ASAPPSDK.Source, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, downloadTaskUpdated: ASAPPSDK.DownloadTaskUpdatedBlock? = nil, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)?) -> ASAPPSDK.DownloadTask?
  #endif
  @objc deinit
}
extension ASAPPSDK.KingfisherManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func retrieveImage(with resource: any ASAPPSDK.Resource, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil) async throws -> ASAPPSDK.RetrieveImageResult
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func retrieveImage(with source: ASAPPSDK.Source, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil) async throws -> ASAPPSDK.RetrieveImageResult
  #endif
}
public protocol ImageDataProvider : Swift.Sendable {
  var cacheKey: Swift.String { get }
  #if compiler(>=5.3) && $Sendable
  func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  var contentURL: Foundation.URL? { get }
}
extension ASAPPSDK.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> ASAPPSDK.Source
}
public struct LocalFileImageDataProvider : ASAPPSDK.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: ASAPPSDK.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  public var cacheKey: Swift.String
  #if compiler(>=5.3) && $Sendable
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var data: Foundation.Data {
    get async throws
  }
  #endif
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : ASAPPSDK.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : ASAPPSDK.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct ThumbnailImageDataProvider : ASAPPSDK.ImageDataProvider {
  public enum ThumbnailImageDataProviderError : Swift.Error {
    case invalidImageSource
    case invalidThumbnail
    case writeDataError
    case finalizeDataError
    public static func == (a: ASAPPSDK.ThumbnailImageDataProvider.ThumbnailImageDataProviderError, b: ASAPPSDK.ThumbnailImageDataProvider.ThumbnailImageDataProviderError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let url: Foundation.URL
  public var maxPixelSize: CoreFoundation.CGFloat
  public var alwaysCreateThumbnail: Swift.Bool
  public var cacheKey: Swift.String
  public init(url: Foundation.URL, maxPixelSize: CoreFoundation.CGFloat, alwaysCreateThumbnail: Swift.Bool = true, cacheKey: Swift.String? = nil)
  #if compiler(>=5.3) && $Sendable
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
public protocol ImageDownloadRedirectHandler : Swift.Sendable {
  #if compiler(>=5.3) && $AsyncAwait
  func handleHTTPRedirection(for task: ASAPPSDK.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
}
public struct AnyRedirectHandler : ASAPPSDK.ImageDownloadRedirectHandler {
  #if compiler(>=5.3) && $AsyncAwait
  public func handleHTTPRedirection(for task: ASAPPSDK.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
  #if compiler(>=5.3) && $Sendable
  public init(handle: @escaping @Sendable (ASAPPSDK.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
  #endif
}
extension CoreFoundation.CGSize : ASAPPSDK.KingfisherCompatibleValue {
}
extension ASAPPSDK.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: ASAPPSDK.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload data: Foundation.Data, with task: ASAPPSDK.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload image: ASAPPSDK.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: ASAPPSDK.ImageDownloader) -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
  #endif
}
extension ASAPPSDK.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload image: ASAPPSDK.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: ASAPPSDK.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload data: Foundation.Data, with task: ASAPPSDK.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  #if compiler(>=5.3) && $AsyncAwait
  public func imageDownloader(_ downloader: ASAPPSDK.ImageDownloader, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
  #endif
}
@_Concurrency.MainActor public protocol KFOptionSetter {
  @_Concurrency.MainActor var options: ASAPPSDK.KingfisherParsedOptionsInfo { get nonmutating set }
  @_Concurrency.MainActor var onFailureDelegate: ASAPPSDK.Delegate<ASAPPSDK.KingfisherError, Swift.Void> { get }
  @_Concurrency.MainActor var onSuccessDelegate: ASAPPSDK.Delegate<ASAPPSDK.RetrieveImageResult, Swift.Void> { get }
  @_Concurrency.MainActor var onProgressDelegate: ASAPPSDK.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
}
extension ASAPPSDK.KF.Builder : ASAPPSDK.KFOptionSetter {
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func onProgress(_ block: ASAPPSDK.DownloadProgressBlock?) -> Self
  @_Concurrency.MainActor public func onSuccess(_ block: ((ASAPPSDK.RetrieveImageResult) -> Swift.Void)?) -> Self
  @_Concurrency.MainActor public func onFailure(_ block: ((ASAPPSDK.KingfisherError) -> Swift.Void)?) -> Self
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func targetCache(_ cache: ASAPPSDK.ImageCache) -> Self
  @_Concurrency.MainActor public func originalCache(_ cache: ASAPPSDK.ImageCache) -> Self
  @_Concurrency.MainActor public func downloader(_ downloader: ASAPPSDK.ImageDownloader) -> Self
  @_Concurrency.MainActor public func downloadPriority(_ priority: Swift.Float) -> Self
  @_Concurrency.MainActor public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func callbackQueue(_ queue: ASAPPSDK.CallbackQueue) -> Self
  @_Concurrency.MainActor public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  @_Concurrency.MainActor public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func processingQueue(_ queue: ASAPPSDK.CallbackQueue?) -> Self
  @_Concurrency.MainActor public func alternativeSources(_ sources: [ASAPPSDK.Source]?) -> Self
  @_Concurrency.MainActor public func retry(_ strategy: (any ASAPPSDK.RetryStrategy)?) -> Self
  @_Concurrency.MainActor public func retry(maxCount: Swift.Int, interval: ASAPPSDK.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  @_Concurrency.MainActor public func lowDataModeSource(_ source: ASAPPSDK.Source?) -> Self
  @_Concurrency.MainActor public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func onFailureImage(_ image: ASAPPSDK.KFCrossPlatformImage?) -> Self
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func requestModifier(_ modifier: any ASAPPSDK.AsyncImageDownloadRequestModifier) -> Self
  #if compiler(>=5.3) && $Sendable
  @_Concurrency.MainActor public func requestModifier(_ modifyBlock: @escaping @Sendable (inout Foundation.URLRequest) -> Swift.Void) -> Self
  #endif
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func redirectHandler(_ handler: any ASAPPSDK.ImageDownloadRedirectHandler) -> Self
  #if compiler(>=5.3) && $Sendable
  @_Concurrency.MainActor public func redirectHandler(_ block: @escaping @Sendable (ASAPPSDK.KF.RedirectPayload) -> Swift.Void) -> Self
  #endif
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func setProcessor(_ processor: any ASAPPSDK.ImageProcessor) -> Self
  @_Concurrency.MainActor public func progressiveJPEG(_ progressive: ASAPPSDK.ImageProgressive? = .init()) -> Self
  @_Concurrency.MainActor public func setProcessors(_ processors: [any ASAPPSDK.ImageProcessor]) -> Self
  @_Concurrency.MainActor public func appendProcessor(_ processor: any ASAPPSDK.ImageProcessor) -> Self
  @_Concurrency.MainActor public func roundCorner(radius: ASAPPSDK.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ASAPPSDK.RectCorner = .all, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil) -> Self
  @_Concurrency.MainActor public func blur(radius: CoreFoundation.CGFloat) -> Self
  @_Concurrency.MainActor public func overlay(color: ASAPPSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  @_Concurrency.MainActor public func tint(color: ASAPPSDK.KFCrossPlatformColor) -> Self
  @_Concurrency.MainActor public func blackWhite() -> Self
  @_Concurrency.MainActor public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  @_Concurrency.MainActor public func downsampling(size: CoreFoundation.CGSize) -> Self
  @_Concurrency.MainActor public func resizing(referenceSize: CoreFoundation.CGSize, mode: ASAPPSDK.ContentMode = .none) -> Self
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func serialize(by cacheSerializer: any ASAPPSDK.CacheSerializer) -> Self
  @_Concurrency.MainActor public func serialize(as format: ASAPPSDK.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func imageModifier(_ modifier: (any ASAPPSDK.ImageModifier)?) -> Self
  #if compiler(>=5.3) && $Sendable
  @_Concurrency.MainActor public func imageModifier(_ block: @escaping @Sendable (inout ASAPPSDK.KFCrossPlatformImage) throws -> Swift.Void) -> Self
  #endif
}
extension ASAPPSDK.KFOptionSetter {
  @_Concurrency.MainActor public func memoryCacheExpiration(_ expiration: ASAPPSDK.StorageExpiration?) -> Self
  @_Concurrency.MainActor public func memoryCacheAccessExtending(_ extending: ASAPPSDK.ExpirationExtending) -> Self
  @_Concurrency.MainActor public func diskCacheExpiration(_ expiration: ASAPPSDK.StorageExpiration?) -> Self
  @_Concurrency.MainActor public func diskCacheAccessExtending(_ extending: ASAPPSDK.ExpirationExtending) -> Self
}
@_hasMissingDesignatedInitializers public class SessionDataTask : @unchecked Swift.Sendable {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
public struct LivePhotoResourceDownloadingResult : Swift.Sendable {
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
  public init(originalData: Foundation.Data, url: Foundation.URL? = nil)
}
extension ASAPPSDK.ImageDownloader {
  #if compiler(>=5.3) && $AsyncAwait
  public func downloadLivePhotoResource(with url: Foundation.URL, options: ASAPPSDK.KingfisherParsedOptionsInfo) async throws -> ASAPPSDK.LivePhotoResourceDownloadingResult
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  public func downloadLivePhotoResource(with url: Foundation.URL, options: ASAPPSDK.KingfisherParsedOptionsInfo, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.LivePhotoResourceDownloadingResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask
  #endif
}
extension QuartzCore.CADisplayLink : @unchecked Swift.Sendable {
}
public protocol Resource : Swift.Sendable {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension ASAPPSDK.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> ASAPPSDK.Source
}
@available(*, deprecated, renamed: "KF.ImageResource", message: "This type conflicts with `GeneratedAssetSymbols.ImageResource` in Swift 5.9. Renamed to avoid issues in the future.")
extension ASAPPSDK.KF {
  public struct ImageResource : ASAPPSDK.Resource {
    public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
    public let cacheKey: Swift.String
    public let downloadURL: Foundation.URL
  }
}
extension Foundation.URL : ASAPPSDK.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImageProtocol {
  @_Concurrency.MainActor public static func source(_ source: ASAPPSDK.Source?) -> Self
  @_Concurrency.MainActor public static func resource(_ resource: (any ASAPPSDK.Resource)?) -> Self
  @_Concurrency.MainActor public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> Self
  @_Concurrency.MainActor public static func dataProvider(_ provider: (any ASAPPSDK.ImageDataProvider)?) -> Self
  @_Concurrency.MainActor public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> Self
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImageProtocol {
  @_Concurrency.MainActor public func placeholder<P>(@SwiftUI.ViewBuilder _ content: @escaping (Foundation.Progress) -> P) -> Self where P : SwiftUI.View
  @_Concurrency.MainActor public func placeholder<P>(@SwiftUI.ViewBuilder _ content: @escaping () -> P) -> Self where P : SwiftUI.View
  @_Concurrency.MainActor public func onFailureView<F>(@SwiftUI.ViewBuilder _ content: @escaping () -> F) -> Self where F : SwiftUI.View
  @_Concurrency.MainActor public func cancelOnDisappear(_ flag: Swift.Bool) -> Self
  @_Concurrency.MainActor public func reducePriorityOnDisappear(_ flag: Swift.Bool) -> Self
  @_Concurrency.MainActor public func fade(duration: Foundation.TimeInterval) -> Self
  @_Concurrency.MainActor public func startLoadingBeforeViewAppear(_ flag: Swift.Bool = true) -> Self
  @_Concurrency.MainActor public func loadTransition(_ transition: SwiftUI.AnyTransition, animation: SwiftUI.Animation? = .default) -> Self
  @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
  @_Concurrency.MainActor public func loadTransition<T>(_ transition: T, animation: SwiftUI.Animation? = .default) -> Self where T : SwiftUI.Transition
}
public typealias PrefetcherProgressBlock = ((_ skippedResources: [any ASAPPSDK.Resource], _ failedResources: [any ASAPPSDK.Resource], _ completedResources: [any ASAPPSDK.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = ((_ skippedSources: [ASAPPSDK.Source], _ failedSources: [ASAPPSDK.Source], _ completedSources: [ASAPPSDK.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = ((_ skippedResources: [any ASAPPSDK.Resource], _ failedResources: [any ASAPPSDK.Resource], _ completedResources: [any ASAPPSDK.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = ((_ skippedSources: [ASAPPSDK.Source], _ failedSources: [ASAPPSDK.Source], _ completedSources: [ASAPPSDK.Source]) -> Swift.Void)
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.PrefetcherProgressBlock? = nil, completionHandler: ASAPPSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any ASAPPSDK.Resource], options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.PrefetcherProgressBlock? = nil, completionHandler: ASAPPSDK.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [ASAPPSDK.Source], options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.PrefetcherSourceProgressBlock? = nil, completionHandler: ASAPPSDK.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public protocol KFImageProtocol : ASAPPSDK.KFOptionSetter, SwiftUI.View {
  associatedtype HoldingView : ASAPPSDK.KFImageHoldingView, Swift.Sendable
  @_Concurrency.MainActor var context: ASAPPSDK.KFImage.Context<Self.HoldingView> { get set }
  @_Concurrency.MainActor init(context: ASAPPSDK.KFImage.Context<Self.HoldingView>)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImageProtocol {
  @_Concurrency.MainActor public var body: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor public init(source: ASAPPSDK.Source?)
  @_Concurrency.MainActor public init(_ url: Foundation.URL?)
  @_Concurrency.MainActor public func configure(_ block: @escaping (Self.HoldingView) -> Self.HoldingView) -> Self
  @_Concurrency.MainActor public func contentConfigure<V>(_ block: @escaping (Self.HoldingView) -> V) -> Self where V : SwiftUI.View
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public protocol KFImageHoldingView : SwiftUI.View {
  associatedtype RenderingView
  @_Concurrency.MainActor static func created(from image: ASAPPSDK.KFCrossPlatformImage?, context: ASAPPSDK.KFImage.Context<Self>) -> Self
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImageProtocol {
  @_Concurrency.MainActor public var options: ASAPPSDK.KingfisherParsedOptionsInfo {
    get
    nonmutating set
  }
  @_Concurrency.MainActor public var onFailureDelegate: ASAPPSDK.Delegate<ASAPPSDK.KingfisherError, Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var onSuccessDelegate: ASAPPSDK.Delegate<ASAPPSDK.RetrieveImageResult, Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var onProgressDelegate: ASAPPSDK.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> {
    get
  }
  @_Concurrency.MainActor public var delegateObserver: Swift.AnyObject {
    get
  }
}
public enum KF {
  public static func source(_ source: ASAPPSDK.Source?) -> ASAPPSDK.KF.Builder
  public static func resource(_ resource: (any ASAPPSDK.Resource)?) -> ASAPPSDK.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> ASAPPSDK.KF.Builder
  public static func dataProvider(_ provider: (any ASAPPSDK.ImageDataProvider)?) -> ASAPPSDK.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> ASAPPSDK.KF.Builder
}
extension ASAPPSDK.KF {
  @_hasMissingDesignatedInitializers public class Builder : @unchecked Swift.Sendable {
    public var options: ASAPPSDK.KingfisherParsedOptionsInfo {
      get
      set
    }
    final public let onFailureDelegate: ASAPPSDK.Delegate<ASAPPSDK.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: ASAPPSDK.Delegate<ASAPPSDK.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: ASAPPSDK.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
@_Concurrency.MainActor extension ASAPPSDK.KF.Builder {
  @discardableResult
  @_Concurrency.MainActor public func set(to imageView: ASAPPSDK.KFCrossPlatformImageView) -> ASAPPSDK.DownloadTask?
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping @Sendable () -> ASAPPSDK.KFCrossPlatformView) -> ASAPPSDK.DownloadTask?
  #endif
  @discardableResult
  @_Concurrency.MainActor public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> ASAPPSDK.DownloadTask?
  @discardableResult
  @_Concurrency.MainActor public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> ASAPPSDK.DownloadTask?
  @available(iOS 14.0, *)
  @discardableResult
  @_Concurrency.MainActor public func set(to listItem: CarPlay.CPListItem) -> ASAPPSDK.DownloadTask?
}
extension ASAPPSDK.KF.Builder {
  public func placeholder(_ placeholder: (any ASAPPSDK.Placeholder)?) -> Self
  public func placeholder(_ image: ASAPPSDK.KFCrossPlatformImage?) -> Self
}
extension ASAPPSDK.KF.Builder {
  public func transition(_ transition: ASAPPSDK.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
}
extension ASAPPSDK.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension ASAPPSDK.KF {
  public struct RedirectPayload {
    public let task: ASAPPSDK.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers final public class Backend<T> : @unchecked Swift.Sendable where T : ASAPPSDK.DataTransformable, T : Swift.Sendable {
    final public var config: ASAPPSDK.DiskStorage.Config {
      get
      set
    }
    final public let directoryURL: Foundation.URL
    convenience public init(config: ASAPPSDK.DiskStorage.Config) throws
    final public func store(value: T, forKey key: Swift.String, expiration: ASAPPSDK.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = [], forcedExtension: Swift.String? = nil) throws
    final public func value(forKey key: Swift.String, forcedExtension: Swift.String? = nil, extendingExpiration: ASAPPSDK.ExpirationExtending = .cacheTime) throws -> T?
    final public func isCached(forKey key: Swift.String, forcedExtension: Swift.String? = nil) -> Swift.Bool
    final public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date, forcedExtension: Swift.String? = nil) -> Swift.Bool
    final public func remove(forKey key: Swift.String, forcedExtension: Swift.String? = nil) throws
    final public func removeAll() throws
    final public func cacheFileURL(forKey key: Swift.String, forcedExtension: Swift.String? = nil) -> Foundation.URL
    final public func removeExpiredValues() throws -> [Foundation.URL]
    final public func removeSizeExceededValues() throws -> [Foundation.URL]
    final public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension ASAPPSDK.DiskStorage {
  public struct Config : @unchecked Swift.Sendable {
    public var sizeLimit: Swift.UInt
    public var expiration: ASAPPSDK.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: (@Sendable (_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public let name: Swift.String
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> : @unchecked Swift.Sendable {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension ASAPPSDK.KingfisherCompatible {
  public var kf: ASAPPSDK.KingfisherWrapper<Self> {
    get
    set
  }
}
extension ASAPPSDK.KingfisherCompatibleValue {
  public var kf: ASAPPSDK.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : ASAPPSDK.KingfisherCompatible {
}
extension UIKit.UIImageView : ASAPPSDK.KingfisherCompatible {
}
extension UIKit.UIButton : ASAPPSDK.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : ASAPPSDK.KingfisherCompatible {
}
extension PhotosUI.PHLivePhotoView : ASAPPSDK.KingfisherCompatible {
}
@available(iOS 14.0, *)
extension CarPlay.CPListItem : ASAPPSDK.KingfisherCompatible {
}
extension Swift.String : ASAPPSDK.KingfisherCompatibleValue {
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: ASAPPSDK.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: ASAPPSDK.AnimatedImageView)
}
extension ASAPPSDK.AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: ASAPPSDK.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: ASAPPSDK.AnimatedImageView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedImageView : ASAPPSDK.KFCrossPlatformImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: ASAPPSDK.AnimatedImageView.RepeatCount, rhs: ASAPPSDK.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) public var autoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var framePreloadCount: Swift.Int
  @_Concurrency.MainActor(unsafe) public var needsPrescaling: Swift.Bool
  @available(*, deprecated, message: "    This property does not perform as declared and may lead to performance degradation.\n    It is currently obsolete and scheduled for removal in a future version.")
  @_Concurrency.MainActor(unsafe) public var backgroundDecode: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var repeatCount: ASAPPSDK.AnimatedImageView.RepeatCount {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any ASAPPSDK.AnimatedImageViewDelegate)?
  @_Concurrency.MainActor(unsafe) public var animator: ASAPPSDK.AnimatedImageView.Animator? {
    get
  }
  @_Concurrency.MainActor @objc override dynamic open var image: ASAPPSDK.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension ASAPPSDK.AnimatedImageView {
  @_hasMissingDesignatedInitializers public class Animator : @unchecked Swift.Sendable {
    final public let maxFrameCount: Swift.Int
    public var currentFrameImage: ASAPPSDK.KFCrossPlatformImage? {
      get
    }
    public var currentFrameDuration: Foundation.TimeInterval {
      get
    }
    public var currentFrameIndex: Swift.Int {
      get
    }
    public var isLastFrame: Swift.Bool {
      get
    }
    public func frame(at index: Swift.Int) -> ASAPPSDK.KFCrossPlatformImage?
    public func duration(at index: Swift.Int) -> Foundation.TimeInterval
    @objc deinit
  }
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason : Swift.Sendable {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: ASAPPSDK.SessionDataTask, token: ASAPPSDK.SessionDataTask.CancelToken)
    case livePhotoTaskCancelled(source: ASAPPSDK.LivePhotoSource)
    case asyncTaskContextCancelled
  }
  public enum ResponseErrorReason : Swift.Sendable {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: ASAPPSDK.SessionDataTask)
    case noURLResponse(task: ASAPPSDK.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason : @unchecked Swift.Sendable {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: ASAPPSDK.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any ASAPPSDK.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
    case missingLivePhotoResourceOnDisk(_: ASAPPSDK.LivePhotoResource)
  }
  public enum ProcessorErrorReason : Swift.Sendable {
    case processingFailed(processor: any ASAPPSDK.ImageProcessor, item: ASAPPSDK.ImageProcessItem)
  }
  public enum ImageSettingErrorReason : Swift.Sendable {
    case emptySource
    case notCurrentSourceTask(result: ASAPPSDK.RetrieveImageResult?, error: (any Swift.Error)?, source: ASAPPSDK.Source)
    case dataProviderError(provider: any ASAPPSDK.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([ASAPPSDK.PropagationError])
    case notCurrentLivePhotoSourceTask(result: ASAPPSDK.RetrieveLivePhotoResult?, error: (any Swift.Error)?, source: ASAPPSDK.LivePhotoSource)
    case livePhotoResultError(result: ASAPPSDK.RetrieveLivePhotoResult?, error: (any Swift.Error)?, source: ASAPPSDK.LivePhotoSource)
  }
  case requestError(reason: ASAPPSDK.KingfisherError.RequestErrorReason)
  case responseError(reason: ASAPPSDK.KingfisherError.ResponseErrorReason)
  case cacheError(reason: ASAPPSDK.KingfisherError.CacheErrorReason)
  case processorError(reason: ASAPPSDK.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: ASAPPSDK.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension ASAPPSDK.KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ASAPPSDK.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: any ASAPPSDK.Indicator)
}
@_Concurrency.MainActor public protocol Indicator : Swift.Sendable {
  @_Concurrency.MainActor func startAnimatingView()
  @_Concurrency.MainActor func stopAnimatingView()
  @_Concurrency.MainActor var centerOffset: CoreFoundation.CGPoint { get }
  @_Concurrency.MainActor var view: ASAPPSDK.IndicatorView { get }
  @_Concurrency.MainActor func sizeStrategy(in imageView: ASAPPSDK.KFCrossPlatformImageView) -> ASAPPSDK.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension ASAPPSDK.Indicator {
  @_Concurrency.MainActor public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor public func sizeStrategy(in imageView: ASAPPSDK.KFCrossPlatformImageView) -> ASAPPSDK.IndicatorSizeStrategy
}
extension AVFoundation.AVAssetImageGenerator : @unchecked Swift.Sendable {
}
public struct AVAssetImageDataProvider : ASAPPSDK.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  #if compiler(>=5.3) && $Sendable
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
@available(iOS 14.0, macOS 13.0, *)
extension PhotosUI.PHPickerResult : @unchecked Swift.Sendable {
}
@available(iOS 14.0, macOS 13.0, *)
public struct PHPickerResultImageDataProvider : ASAPPSDK.ImageDataProvider {
  public enum PHPickerResultImageDataProviderError : Swift.Error {
    case pickerProviderError(any Swift.Error)
    case invalidImage
  }
  public let pickerResult: PhotosUI.PHPickerResult
  public let contentType: UniformTypeIdentifiers.UTType
  public var cacheKey: Swift.String {
    get
  }
  public init(pickerResult: PhotosUI.PHPickerResult, contentType: UniformTypeIdentifiers.UTType = UTType.image)
  #if compiler(>=5.3) && $Sendable
  public func data(handler: @escaping @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
}
public enum MemoryStorage {
  final public class Backend<T> : @unchecked Swift.Sendable where T : ASAPPSDK.CacheCostCalculable, T : Swift.Sendable {
    final public var config: ASAPPSDK.MemoryStorage.Config {
      get
      set
    }
    public init(config: ASAPPSDK.MemoryStorage.Config)
    final public func removeExpired()
    final public func store(value: T, forKey key: Swift.String, expiration: ASAPPSDK.StorageExpiration? = nil)
    final public func value(forKey key: Swift.String, extendingExpiration: ASAPPSDK.ExpirationExtending = .cacheTime) -> T?
    final public func isCached(forKey key: Swift.String) -> Swift.Bool
    final public func remove(forKey key: Swift.String)
    final public func removeAll()
    @objc deinit
  }
}
extension ASAPPSDK.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: ASAPPSDK.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
@_hasMissingDesignatedInitializers public class RetryContext : @unchecked Swift.Sendable {
  final public let source: ASAPPSDK.Source
  final public let error: ASAPPSDK.KingfisherError
  public var retriedCount: Swift.Int {
    get
    set
  }
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy : Swift.Sendable {
  #if compiler(>=5.3) && $Sendable
  func retry(context: ASAPPSDK.RetryContext, retryHandler: @escaping @Sendable (ASAPPSDK.RetryDecision) -> Swift.Void)
  #endif
}
public struct DelayRetryStrategy : ASAPPSDK.RetryStrategy {
  public enum Interval : Swift.Sendable {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: @Sendable (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: ASAPPSDK.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: ASAPPSDK.DelayRetryStrategy.Interval = .seconds(3))
  #if compiler(>=5.3) && $Sendable
  public func retry(context: ASAPPSDK.RetryContext, retryHandler: @escaping @Sendable (ASAPPSDK.RetryDecision) -> Swift.Void)
  #endif
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImage {
  @_hasMissingDesignatedInitializers public class Context<HoldingView> : @unchecked Swift.Sendable where HoldingView : ASAPPSDK.KFImageHoldingView, HoldingView : Swift.Sendable {
    @objc deinit
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFImage.Context : Swift.Hashable {
  public static func == (lhs: ASAPPSDK.KFImage.Context<HoldingView>, rhs: ASAPPSDK.KFImage.Context<HoldingView>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
extension ASAPPSDK.KFAnimatedImage {
  public typealias Context = ASAPPSDK.KFImage.Context
}
public enum Source : Swift.Sendable {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any ASAPPSDK.Resource)
  case provider(any ASAPPSDK.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension ASAPPSDK.Source : Swift.Hashable {
  public static func == (lhs: ASAPPSDK.Source, rhs: ASAPPSDK.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Placeholder {
  @_Concurrency.MainActor func add(to imageView: ASAPPSDK.KFCrossPlatformImageView)
  @_Concurrency.MainActor func remove(from imageView: ASAPPSDK.KFCrossPlatformImageView)
}
@_Concurrency.MainActor extension UIKit.UIImage : ASAPPSDK.Placeholder {
  @_Concurrency.MainActor public func add(to imageView: ASAPPSDK.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: ASAPPSDK.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func add(to base: any ASAPPSDK.KingfisherHasImageComponent)
  @_Concurrency.MainActor public func remove(from base: any ASAPPSDK.KingfisherHasImageComponent)
}
@_Concurrency.MainActor extension ASAPPSDK.Placeholder where Self : UIKit.UIView {
  @_Concurrency.MainActor public func add(to imageView: ASAPPSDK.KFCrossPlatformImageView)
  @_Concurrency.MainActor public func remove(from imageView: ASAPPSDK.KFCrossPlatformImageView)
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = ASAPPSDK.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  #if compiler(>=5.3) && $AsyncAwait
  func downloader(_ downloader: ASAPPSDK.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func downloader(_ downloader: ASAPPSDK.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
}
extension ASAPPSDK.AuthenticationChallengeResponsible {
  #if compiler(>=5.3) && $AsyncAwait
  public func downloader(_ downloader: ASAPPSDK.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func downloader(_ downloader: ASAPPSDK.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
}
public enum ImageFormat : Swift.Sendable {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: ASAPPSDK.ImageFormat, b: ASAPPSDK.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : ASAPPSDK.KingfisherCompatibleValue {
}
extension ASAPPSDK.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: ASAPPSDK.ImageFormat {
    get
  }
  public func contains(jpeg marker: ASAPPSDK.ImageFormat.JPEGMarker) -> Swift.Bool
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIButton {
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: ASAPPSDK.KingfisherParsedOptionsInfo, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelImageDownloadTask()
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with source: ASAPPSDK.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setBackgroundImage(with resource: (any ASAPPSDK.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelBackgroundImageDownloadTask()
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIButton {
  @_Concurrency.MainActor public func taskIdentifier(for state: UIKit.UIControl.State) -> ASAPPSDK.Source.Identifier.Value?
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIButton {
  @_Concurrency.MainActor public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> ASAPPSDK.Source.Identifier.Value?
}
public class Delegate<Input, Output> : @unchecked Swift.Sendable {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  #if compiler(>=5.3) && $AsyncAwait
  public func delegate<T>(on target: T, block: ((T, Input) async -> Output)?) where T : AnyObject
  #endif
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  #if compiler(>=5.3) && $AsyncAwait
  public func callAsync(_ input: Input) async -> Output?
  #endif
  public var isSet: Swift.Bool {
    get
  }
  @objc deinit
}
extension ASAPPSDK.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension ASAPPSDK.Delegate where Input == (), Output : ASAPPSDK.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension ASAPPSDK.Delegate where Output : ASAPPSDK.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
extension Swift.Optional : ASAPPSDK.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  @objc override dynamic public init()
  @objc deinit
}
extension ASAPPSDK.SessionDelegate : Foundation.URLSessionDataDelegate {
  #if compiler(>=5.3) && $AsyncAwait
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse) async -> Foundation.URLSession.ResponseDisposition
  #endif
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  #if compiler(>=5.3) && $AsyncAwait
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
}
public protocol AsyncImageDownloadRequestModifier : Swift.Sendable {
  #if compiler(>=5.3) && $AsyncAwait
  func modified(for request: Foundation.URLRequest) async -> Foundation.URLRequest?
  #endif
  #if compiler(>=5.3) && $Sendable
  var onDownloadTaskStarted: (@Sendable (ASAPPSDK.DownloadTask?) -> Swift.Void)? { get }
  #endif
}
public protocol ImageDownloadRequestModifier : ASAPPSDK.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension ASAPPSDK.ImageDownloadRequestModifier {
  #if compiler(>=5.3) && $Sendable
  public var onDownloadTaskStarted: (@Sendable (ASAPPSDK.DownloadTask?) -> Swift.Void)? {
    get
  }
  #endif
}
public struct AnyModifier : ASAPPSDK.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  #if compiler(>=5.3) && $Sendable
  public init(modify: @escaping @Sendable (Foundation.URLRequest) -> Foundation.URLRequest?)
  #endif
}
public protocol CacheSerializer : Swift.Sendable {
  func data(with image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
  var originalDataUsed: Swift.Bool { get }
}
extension ASAPPSDK.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : ASAPPSDK.CacheSerializer {
  public static let `default`: ASAPPSDK.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  public func data(with image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public typealias KingfisherOptionsInfo = [ASAPPSDK.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem : Swift.Sendable {
  case targetCache(ASAPPSDK.ImageCache)
  case originalCache(ASAPPSDK.ImageCache)
  case downloader(ASAPPSDK.ImageDownloader)
  case transition(ASAPPSDK.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(ASAPPSDK.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any ASAPPSDK.AsyncImageDownloadRequestModifier)
  case redirectHandler(any ASAPPSDK.ImageDownloadRedirectHandler)
  case processor(any ASAPPSDK.ImageProcessor)
  case cacheSerializer(any ASAPPSDK.CacheSerializer)
  case imageModifier(any ASAPPSDK.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(ASAPPSDK.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(ASAPPSDK.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(ASAPPSDK.ExpirationExtending)
  case diskCacheExpiration(ASAPPSDK.StorageExpiration)
  case diskCacheAccessExtendingExpiration(ASAPPSDK.ExpirationExtending)
  case processingQueue(ASAPPSDK.CallbackQueue)
  case progressiveJPEG(ASAPPSDK.ImageProgressive)
  case alternativeSources([ASAPPSDK.Source])
  case retryStrategy(any ASAPPSDK.RetryStrategy)
  case lowDataMode(ASAPPSDK.Source?)
  case forcedCacheFileExtension(Swift.String?)
}
public struct KingfisherParsedOptionsInfo : Swift.Sendable {
  public var targetCache: ASAPPSDK.ImageCache?
  public var originalCache: ASAPPSDK.ImageCache?
  public var downloader: ASAPPSDK.ImageDownloader?
  public var transition: ASAPPSDK.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: ASAPPSDK.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any ASAPPSDK.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any ASAPPSDK.ImageDownloadRedirectHandler)?
  public var processor: any ASAPPSDK.ImageProcessor
  public var imageModifier: (any ASAPPSDK.ImageModifier)?
  public var cacheSerializer: any ASAPPSDK.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: ASAPPSDK.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: ASAPPSDK.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: ASAPPSDK.ExpirationExtending
  public var diskCacheExpiration: ASAPPSDK.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: ASAPPSDK.ExpirationExtending
  public var processingQueue: ASAPPSDK.CallbackQueue?
  public var progressiveJPEG: ASAPPSDK.ImageProgressive?
  public var alternativeSources: [ASAPPSDK.Source]?
  public var retryStrategy: (any ASAPPSDK.RetryStrategy)?
  public var lowDataModeSource: ASAPPSDK.Source?
  public var forcedExtension: Swift.String?
  public init(_ info: ASAPPSDK.KingfisherOptionsInfo?)
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImageView {
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.Source?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with resource: (any ASAPPSDK.Resource)?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any ASAPPSDK.ImageDataProvider)?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with provider: (any ASAPPSDK.ImageDataProvider)?, placeholder: (any ASAPPSDK.Placeholder)? = nil, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveImageResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask?
  #endif
  @_Concurrency.MainActor public func cancelDownloadTask()
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImageView {
  @_Concurrency.MainActor public var taskIdentifier: ASAPPSDK.Source.Identifier.Value? {
    get
  }
  @_Concurrency.MainActor public var indicatorType: ASAPPSDK.IndicatorType {
    get
    set
  }
  @_Concurrency.MainActor public var indicator: (any ASAPPSDK.Indicator)? {
    get
  }
  @_Concurrency.MainActor public var placeholder: (any ASAPPSDK.Placeholder)? {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType : Swift.Sendable {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: ASAPPSDK.CacheType, b: ASAPPSDK.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult : Swift.Sendable {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), ASAPPSDK.KingfisherError>
}
extension UIKit.UIImage : ASAPPSDK.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : ASAPPSDK.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult : Swift.Sendable {
  case disk(ASAPPSDK.KFCrossPlatformImage)
  case memory(ASAPPSDK.KFCrossPlatformImage)
  case none
  public var image: ASAPPSDK.KFCrossPlatformImage? {
    get
  }
  public var cacheType: ASAPPSDK.CacheType {
    get
  }
}
open class ImageCache : @unchecked Swift.Sendable {
  public static let `default`: ASAPPSDK.ImageCache
  final public let memoryStorage: ASAPPSDK.MemoryStorage.Backend<ASAPPSDK.KFCrossPlatformImage>
  final public let diskStorage: ASAPPSDK.DiskStorage.Backend<Foundation.Data>
  #if compiler(>=5.3) && $Sendable
  public typealias DiskCachePathClosure = @Sendable (Foundation.URL, Swift.String) -> Foundation.URL
  #endif
  public init(memoryStorage: ASAPPSDK.MemoryStorage.Backend<ASAPPSDK.KFCrossPlatformImage>, diskStorage: ASAPPSDK.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  #if compiler(>=5.3) && $Sendable
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: ASAPPSDK.ImageCache.DiskCachePathClosure? = nil) throws
  #endif
  @objc deinit
  #if compiler(>=5.3) && $Sendable
  open func store(_ image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: ASAPPSDK.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: (@Sendable (ASAPPSDK.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func store(_ image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, cacheSerializer serializer: any ASAPPSDK.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: ASAPPSDK.CallbackQueue = .untouch, completionHandler: (@Sendable (ASAPPSDK.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, expiration: ASAPPSDK.StorageExpiration? = nil, callbackQueue: ASAPPSDK.CallbackQueue = .untouch, completionHandler: (@Sendable (ASAPPSDK.CacheStoreResult) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: ASAPPSDK.CallbackQueue = .untouch, completionHandler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func retrieveImage(forKey key: Swift.String, options: ASAPPSDK.KingfisherParsedOptionsInfo, callbackQueue: ASAPPSDK.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.ImageCacheResult, ASAPPSDK.KingfisherError>) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func retrieveImage(forKey key: Swift.String, options: ASAPPSDK.KingfisherOptionsInfo? = nil, callbackQueue: ASAPPSDK.CallbackQueue = .mainCurrentOrAsync, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.ImageCacheResult, ASAPPSDK.KingfisherError>) -> Swift.Void)?)
  #endif
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: ASAPPSDK.KingfisherOptionsInfo? = nil) -> ASAPPSDK.KFCrossPlatformImage?
  #if compiler(>=5.3) && $Sendable
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: ASAPPSDK.KingfisherOptionsInfo? = nil, callbackQueue: ASAPPSDK.CallbackQueue = .untouch, completionHandler: @escaping @Sendable (Swift.Result<ASAPPSDK.KFCrossPlatformImage?, ASAPPSDK.KingfisherError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $Sendable
  public func clearCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  @objc public func clearMemoryCache()
  #if compiler(>=5.3) && $Sendable
  open func clearDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $Sendable
  open func cleanExpiredCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  open func cleanExpiredMemoryCache()
  #if compiler(>=5.3) && $Sendable
  open func cleanExpiredDiskCache(completion handler: (@Sendable () -> Swift.Void)? = nil)
  #endif
  @_Concurrency.MainActor @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> ASAPPSDK.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.String
  #if compiler(>=5.3) && $Sendable
  open func calculateDiskStorageSize(completion handler: @escaping (@Sendable (Swift.Result<Swift.UInt, ASAPPSDK.KingfisherError>) -> Swift.Void))
  #endif
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Swift.String
  open func cacheFileURLIfOnDisk(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier, forcedExtension: Swift.String? = nil) -> Foundation.URL?
  #if compiler(>=5.3) && $AsyncAwait
  open func store(_ image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: ASAPPSDK.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func store(_ image: ASAPPSDK.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, cacheSerializer serializer: any ASAPPSDK.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, expiration: ASAPPSDK.StorageExpiration? = nil) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", forcedExtension: Swift.String? = nil, fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true) async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func retrieveImage(forKey key: Swift.String, options: ASAPPSDK.KingfisherParsedOptionsInfo) async throws -> ASAPPSDK.ImageCacheResult
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func retrieveImage(forKey key: Swift.String, options: ASAPPSDK.KingfisherOptionsInfo? = nil) async throws -> ASAPPSDK.ImageCacheResult
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: ASAPPSDK.KingfisherOptionsInfo? = nil) async throws -> ASAPPSDK.KFCrossPlatformImage?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func clearCache() async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func clearDiskCache() async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func cleanExpiredCache() async
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  open func cleanExpiredDiskCache() async
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
  #endif
}
extension UIKit.UIApplication : ASAPPSDK.KingfisherCompatible {
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
public enum ImageTransition : Swift.Sendable {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: (@_Concurrency.MainActor @Sendable (UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: (@Sendable (Swift.Bool) -> Swift.Void)?)
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
  public var frameSource: (any ASAPPSDK.ImageFrameSource)? {
    get
  }
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: ASAPPSDK.KFCrossPlatformImage {
    get
  }
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: ASAPPSDK.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: ASAPPSDK.ImageCreatingOptions) -> ASAPPSDK.KFCrossPlatformImage?
  public static func animatedImage(source: any ASAPPSDK.ImageFrameSource, options: ASAPPSDK.ImageCreatingOptions, baseImage: ASAPPSDK.KFCrossPlatformImage? = nil) -> ASAPPSDK.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: ASAPPSDK.ImageCreatingOptions) -> ASAPPSDK.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage?
}
public enum StorageExpiration : Swift.Sendable {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending : Swift.Sendable {
  case none
  case cacheTime
  case expirationTime(_: ASAPPSDK.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
public enum ImageProcessItem : Swift.Sendable {
  case image(ASAPPSDK.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor : Swift.Sendable {
  var identifier: Swift.String { get }
  func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
extension ASAPPSDK.ImageProcessor {
  public func append(another: any ASAPPSDK.ImageProcessor) -> any ASAPPSDK.ImageProcessor
}
public struct DefaultImageProcessor : ASAPPSDK.ImageProcessor {
  public static let `default`: ASAPPSDK.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.Int
  public static let topLeft: ASAPPSDK.RectCorner
  public static let topRight: ASAPPSDK.RectCorner
  public static let bottomLeft: ASAPPSDK.RectCorner
  public static let bottomRight: ASAPPSDK.RectCorner
  public static let all: ASAPPSDK.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = ASAPPSDK.RectCorner
  public typealias Element = ASAPPSDK.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: ASAPPSDK.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public enum Radius : Swift.Sendable {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let radius: ASAPPSDK.Radius
  public let roundingCorners: ASAPPSDK.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: ASAPPSDK.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ASAPPSDK.RectCorner = .all, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil)
  public init(radius: ASAPPSDK.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ASAPPSDK.RectCorner = .all, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct Border : Swift.Sendable {
  public var color: ASAPPSDK.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: ASAPPSDK.Radius
  public var roundingCorners: ASAPPSDK.RectCorner
  public init(color: ASAPPSDK.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: ASAPPSDK.Radius = .point(0), roundingCorners: ASAPPSDK.RectCorner = .all)
}
public struct BorderImageProcessor : ASAPPSDK.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: ASAPPSDK.Border
  public init(border: ASAPPSDK.Border)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public enum ContentMode : Swift.Sendable {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: ASAPPSDK.ContentMode, b: ASAPPSDK.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: ASAPPSDK.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: ASAPPSDK.ContentMode = .none)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct BlurImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: ASAPPSDK.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: ASAPPSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct TintImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let tint: ASAPPSDK.KFCrossPlatformColor
  public init(tint: ASAPPSDK.KFCrossPlatformColor)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : ASAPPSDK.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : ASAPPSDK.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: any ASAPPSDK.ImageProcessor, right: any ASAPPSDK.ImageProcessor) -> any ASAPPSDK.ImageProcessor
public struct ImageProgressive : Swift.Sendable {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(ASAPPSDK.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax semantic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: ASAPPSDK.ImageProgressive
  public var isBlur: Swift.Bool
  public var isFastestScan: Swift.Bool
  public var scanInterval: Foundation.TimeInterval
  public let onImageUpdated: ASAPPSDK.Delegate<ASAPPSDK.KFCrossPlatformImage, ASAPPSDK.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
public protocol ImageModifier : Swift.Sendable {
  func modify(_ image: ASAPPSDK.KFCrossPlatformImage) -> ASAPPSDK.KFCrossPlatformImage
}
public struct AnyImageModifier : ASAPPSDK.ImageModifier {
  #if compiler(>=5.3) && $Sendable
  public init(modify: @escaping @Sendable (ASAPPSDK.KFCrossPlatformImage) throws -> ASAPPSDK.KFCrossPlatformImage)
  #endif
  public func modify(_ image: ASAPPSDK.KFCrossPlatformImage) -> ASAPPSDK.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : ASAPPSDK.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: ASAPPSDK.KFCrossPlatformImage) -> ASAPPSDK.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : ASAPPSDK.ImageModifier {
  public init()
  public func modify(_ image: ASAPPSDK.KFCrossPlatformImage) -> ASAPPSDK.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : ASAPPSDK.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: ASAPPSDK.KFCrossPlatformImage) -> ASAPPSDK.KFCrossPlatformImage
}
public struct ImageLoadingResult : Swift.Sendable {
  public let image: ASAPPSDK.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
  public init(image: ASAPPSDK.KFCrossPlatformImage, url: Foundation.URL? = nil, originalData: Foundation.Data)
}
@_hasMissingDesignatedInitializers final public class DownloadTask : @unchecked Swift.Sendable {
  final public var sessionTask: ASAPPSDK.SessionDataTask? {
    get
  }
  final public var cancelToken: ASAPPSDK.SessionDataTask.CancelToken? {
    get
  }
  final public func cancel()
  final public var isInitialized: Swift.Bool {
    get
  }
  @objc deinit
}
open class ImageDownloader : @unchecked Swift.Sendable {
  public static let `default`: ASAPPSDK.ImageDownloader
  open var downloadTimeout: Foundation.TimeInterval {
    get
    set
  }
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: ASAPPSDK.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any ASAPPSDK.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any ASAPPSDK.AuthenticationChallengeResponsible)?
  public init(name: Swift.String)
  @objc deinit
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherParsedOptionsInfo, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.ImageLoadingResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.ImageLoadingResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@Sendable (Swift.Result<ASAPPSDK.ImageLoadingResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> ASAPPSDK.DownloadTask
  #endif
}
extension ASAPPSDK.ImageDownloader {
  #if compiler(>=5.3) && $AsyncAwait
  public func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherParsedOptionsInfo) async throws -> ASAPPSDK.ImageLoadingResult
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil) async throws -> ASAPPSDK.ImageLoadingResult
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func downloadImage(with url: Foundation.URL, options: ASAPPSDK.KingfisherOptionsInfo? = nil) async throws -> ASAPPSDK.ImageLoadingResult
  #endif
}
extension ASAPPSDK.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension ASAPPSDK.ImageDownloader : ASAPPSDK.AuthenticationChallengeResponsible {
}
extension ASAPPSDK.ImageDownloader : ASAPPSDK.ImageDownloaderDelegate {
}
public typealias ExecutionQueue = ASAPPSDK.CallbackQueue
public enum CallbackQueue : Swift.Sendable {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  #if compiler(>=5.3) && $Sendable
  public func execute(_ block: @escaping @Sendable () -> Swift.Void)
  #endif
}
public struct LivePhotoSource : Swift.Sendable {
  public let resources: [ASAPPSDK.LivePhotoResource]
  public init(resources: [any ASAPPSDK.Resource])
  public init(urls: [Foundation.URL])
  public init(_ resources: [ASAPPSDK.LivePhotoResource])
}
public struct LivePhotoResource : Swift.Sendable {
  public enum FileType : Swift.Sendable, Swift.Equatable {
    case heic
    case mov
    case other(Swift.String)
    public static func == (a: ASAPPSDK.LivePhotoResource.FileType, b: ASAPPSDK.LivePhotoResource.FileType) -> Swift.Bool
  }
  public let dataSource: ASAPPSDK.Source
  public let referenceFileType: ASAPPSDK.LivePhotoResource.FileType
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil, fileType: ASAPPSDK.LivePhotoResource.FileType? = nil)
  public init(resource: any ASAPPSDK.Resource, fileType: ASAPPSDK.LivePhotoResource.FileType? = nil)
  public init(source: ASAPPSDK.Source, fileType: ASAPPSDK.LivePhotoResource.FileType? = nil)
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : ASAPPSDK.ImageProcessor {
  var filter: ASAPPSDK.Filter { get }
}
extension ASAPPSDK.CIImageProcessor {
  public func process(item: ASAPPSDK.ImageProcessItem, options: ASAPPSDK.KingfisherParsedOptionsInfo) -> ASAPPSDK.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping ASAPPSDK.Transformer)
  public static let tint: @Sendable (_ color: ASAPPSDK.KFCrossPlatformColor) -> ASAPPSDK.Filter
  public struct ColorElement {
    public let brightness: CoreFoundation.CGFloat
    public let contrast: CoreFoundation.CGFloat
    public let saturation: CoreFoundation.CGFloat
    public let inputEV: CoreFoundation.CGFloat
    public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  }
  public static let colorControl: @Sendable (_ arg: ASAPPSDK.Filter.ColorElement) -> ASAPPSDK.Filter
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: ASAPPSDK.Filter) -> ASAPPSDK.KFCrossPlatformImage
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, *)
@_Concurrency.MainActor public struct KFAnimatedImage : ASAPPSDK.KFImageProtocol {
  public typealias HoldingView = ASAPPSDK.KFAnimatedImageViewRepresenter
  @_Concurrency.MainActor public var context: ASAPPSDK.KFImage.Context<ASAPPSDK.KFAnimatedImage.HoldingView>
  @_Concurrency.MainActor public init(context: ASAPPSDK.KFImage.Context<ASAPPSDK.KFAnimatedImage.HoldingView>)
  @_Concurrency.MainActor public func configure(_ block: @escaping (ASAPPSDK.KFAnimatedImage.HoldingView.RenderingView) -> Swift.Void) -> ASAPPSDK.KFAnimatedImage
  public typealias Body = @_opaqueReturnTypeOf("$s8ASAPPSDK15KFImageProtocolPAAE4bodyQrvp", 0) __<ASAPPSDK.KFAnimatedImage>
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor public struct KFAnimatedImageViewRepresenter : ASAPPSDK.KFImageHoldingView, Swift.Sendable {
  public typealias RenderingView = ASAPPSDK.AnimatedImageView
  @_Concurrency.MainActor public static func created(from image: ASAPPSDK.KFCrossPlatformImage?, context: ASAPPSDK.KFImage.Context<ASAPPSDK.KFAnimatedImageViewRepresenter>) -> ASAPPSDK.KFAnimatedImageViewRepresenter
  @_Concurrency.MainActor(unsafe) public func makeUIView(context: ASAPPSDK.KFAnimatedImageViewRepresenter.Context) -> ASAPPSDK.AnimatedImageView
  @_Concurrency.MainActor(unsafe) public func updateUIView(_ uiView: ASAPPSDK.AnimatedImageView, context: ASAPPSDK.KFAnimatedImageViewRepresenter.Context)
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = ASAPPSDK.AnimatedImageView
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil) -> ASAPPSDK.KFCrossPlatformImage
  public func image(withRadius radius: ASAPPSDK.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: ASAPPSDK.RectCorner = .all, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil) -> ASAPPSDK.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: ASAPPSDK.RectCorner = .all, backgroundColor: ASAPPSDK.KFCrossPlatformColor? = nil) -> ASAPPSDK.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> ASAPPSDK.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: ASAPPSDK.ContentMode) -> ASAPPSDK.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> ASAPPSDK.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage
  public func addingBorder(_ border: ASAPPSDK.Border) -> ASAPPSDK.KFCrossPlatformImage
  public func overlaying(with color: ASAPPSDK.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage
  public func tinted(with color: ASAPPSDK.KFCrossPlatformColor) -> ASAPPSDK.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage
}
extension ASAPPSDK.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: ASAPPSDK.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> ASAPPSDK.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> ASAPPSDK.KFCrossPlatformImage
}
public struct LivePhotoLoadingInfoResult : Swift.Sendable {
  public let fileURLs: [Foundation.URL]
  public let cacheType: ASAPPSDK.CacheType
  public let source: ASAPPSDK.LivePhotoSource
  public let originalSource: ASAPPSDK.LivePhotoSource
  public let data: @Sendable () -> [Foundation.Data]
}
extension ASAPPSDK.KingfisherManager {
  #if compiler(>=5.3) && $AsyncAwait
  public func retrieveLivePhoto(with source: ASAPPSDK.LivePhotoSource, options: ASAPPSDK.KingfisherOptionsInfo? = nil, progressBlock: ASAPPSDK.DownloadProgressBlock? = nil, referenceTaskIdentifierChecker: (() -> Swift.Bool)? = nil) async throws -> ASAPPSDK.LivePhotoLoadingInfoResult
  #endif
}
public struct RetrieveLivePhotoResult : @unchecked Swift.Sendable {
  public let loadingInfo: ASAPPSDK.LivePhotoLoadingInfoResult
  public let livePhoto: Photos.PHLivePhoto?
  public let info: [Swift.AnyHashable : Any]?
}
@_Concurrency.MainActor extension ASAPPSDK.KingfisherWrapper where Base : PhotosUI.PHLivePhotoView {
  @_Concurrency.MainActor public var taskIdentifier: ASAPPSDK.Source.Identifier.Value? {
    get
  }
  @_Concurrency.MainActor public var targetSize: CoreFoundation.CGSize {
    get
    set
  }
  @_Concurrency.MainActor public var contentMode: Photos.PHImageContentMode {
    get
    set
  }
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with urls: [Foundation.URL], options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveLivePhotoResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> _Concurrency.Task<(), Swift.Never>?
  #endif
  #if compiler(>=5.3) && $Sendable
  @discardableResult
  @_Concurrency.MainActor public func setImage(with source: ASAPPSDK.LivePhotoSource?, options: ASAPPSDK.KingfisherOptionsInfo? = nil, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<ASAPPSDK.RetrieveLivePhotoResult, ASAPPSDK.KingfisherError>) -> Swift.Void)? = nil) -> _Concurrency.Task<(), Swift.Never>?
  #endif
}
@objc(ASAPPButtonColors) @objcMembers public class ASAPPButtonColors : ObjectiveC.NSObject {
  @objc public var backgroundNormal: UIKit.UIColor
  @objc @available(*, deprecated)
  public var backgroundHighlighted: UIKit.UIColor
  @objc public var backgroundDisabled: UIKit.UIColor
  @objc public var textNormal: UIKit.UIColor
  @objc public var textHighlighted: UIKit.UIColor
  @objc public var textDisabled: UIKit.UIColor
  @objc public var border: UIKit.UIColor?
  @objc public init(backgroundNormal: UIKit.UIColor, backgroundHighlighted: UIKit.UIColor, backgroundDisabled: UIKit.UIColor, textNormal: UIKit.UIColor, textHighlighted: UIKit.UIColor, textDisabled: UIKit.UIColor, border: UIKit.UIColor?)
  @objc public init(backgroundNormal: UIKit.UIColor, backgroundHighlighted: UIKit.UIColor, backgroundDisabled: UIKit.UIColor, textColor: UIKit.UIColor, border: UIKit.UIColor?)
  @objc public init(textColor: UIKit.UIColor)
  @objc public init(backgroundColor: UIKit.UIColor, textColor: UIKit.UIColor)
  @objc public init(backgroundColor: UIKit.UIColor, textColor: UIKit.UIColor, border: UIKit.UIColor?)
  @objc deinit
}
@objc(ASAPPConfig) @objcMembers public class ASAPPConfig : ObjectiveC.NSObject {
  @objc final public let appId: Swift.String
  @objc final public let apiHostName: Swift.String
  @objc final public let clientSecret: Swift.String
  @objc final public let supportedLanguages: [Swift.String]
  @objc final public let regionCode: Swift.String
  @objc public init(appId: Swift.String, apiHostName: Swift.String, clientSecret: Swift.String, supportedLanguages: [Swift.String] = ["en"], regionCode: Swift.String = "US")
  @objc deinit
}
extension ASAPPSDK.ASAPPConfig {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public var debugDescription: Swift.String {
    @objc get
  }
}
@_inheritsConvenienceInitializers @objc(ASAPPNavBarButtonImages) @objcMembers public class ASAPPNavBarButtonImages : ObjectiveC.NSObject {
  @objc public var close: ASAPPSDK.ASAPPCustomImage? {
    @objc get
    @objc set
  }
  @objc public var back: ASAPPSDK.ASAPPCustomImage? {
    @objc get
    @objc set
  }
  @objc public var more: ASAPPSDK.ASAPPCustomImage? {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol ASAPPChannelDelegate {
  @objc optional func shouldOpenChannel(_ channel: ASAPPSDK.ASAPPChannel) -> Swift.Bool
  @objc func channel(_ channel: ASAPPSDK.ASAPPChannel, didFailToOpenWithErrorDescription errorDescription: Swift.String?)
  @objc func didSelectASAPPChatChannel()
}
extension ASAPPSDK.ASAPPChannelDelegate {
  public func shouldOpenChannel(_ channel: ASAPPSDK.ASAPPChannel) -> Swift.Bool
}
public typealias ulid_t = Foundation.uuid_t
public struct ULID : Swift.Hashable, Swift.Equatable, Swift.Comparable, Swift.CustomStringConvertible {
  public var ulid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8) {
    get
  }
  public init(ulid: ASAPPSDK.ulid_t)
  public init?(ulidData data: Foundation.Data)
  public init?(ulidString string: Swift.String)
  public init<T>(timestamp: Foundation.Date, generator: inout T) where T : Swift.RandomNumberGenerator
  public init(timestamp: Foundation.Date = Date())
  public var ulidData: Foundation.Data {
    get
  }
  public var ulidString: Swift.String {
    get
  }
  public var timestamp: Foundation.Date {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ASAPPSDK.ULID, rhs: ASAPPSDK.ULID) -> Swift.Bool
  public static func < (lhs: ASAPPSDK.ULID, rhs: ASAPPSDK.ULID) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  public static let empty: ASAPPSDK.ULID
  public static let distantPast: ASAPPSDK.ULID
  public static let distantFuture: ASAPPSDK.ULID
  public var hashValue: Swift.Int {
    get
  }
}
extension ASAPPSDK.ULID : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension ASAPPSDK.ThemeBannerStyle : Swift.Equatable {}
extension ASAPPSDK.ThemeBannerStyle : Swift.Hashable {}
extension ASAPPSDK.ASAPPChannel : Swift.Equatable {}
extension ASAPPSDK.ASAPPChannel : Swift.Hashable {}
extension ASAPPSDK.ASAPPChannel : Swift.RawRepresentable {}
extension ASAPPSDK.ASAPPAllowedOrientations : Swift.Equatable {}
extension ASAPPSDK.ASAPPAllowedOrientations : Swift.Hashable {}
extension ASAPPSDK.ASAPPAllowedOrientations : Swift.RawRepresentable {}
extension ASAPPSDK.ASAPPError : Swift.Equatable {}
extension ASAPPSDK.ASAPPError : Swift.Hashable {}
extension ASAPPSDK.ASAPPError : Swift.RawRepresentable {}
extension ASAPPSDK.ASAPPTextStyle.ASAPPCaseStyle : Swift.Equatable {}
extension ASAPPSDK.ASAPPTextStyle.ASAPPCaseStyle : Swift.Hashable {}
extension ASAPPSDK.ASAPPTextStyle.ASAPPCaseStyle : Swift.RawRepresentable {}
extension ASAPPSDK.ASAPPLogLevel : Swift.Equatable {}
extension ASAPPSDK.ASAPPLogLevel : Swift.Hashable {}
extension ASAPPSDK.ASAPPLogLevel : Swift.RawRepresentable {}
extension ASAPPSDK.ButtonWidthType : Swift.Equatable {}
extension ASAPPSDK.ButtonWidthType : Swift.Hashable {}
extension ASAPPSDK.ButtonWidthType : Swift.RawRepresentable {}
extension ASAPPSDK.FeedbackType : Swift.Equatable {}
extension ASAPPSDK.FeedbackType : Swift.Hashable {}
extension ASAPPSDK.ThumbnailImageDataProvider.ThumbnailImageDataProviderError : Swift.Equatable {}
extension ASAPPSDK.ThumbnailImageDataProvider.ThumbnailImageDataProviderError : Swift.Hashable {}
extension ASAPPSDK.ImageFormat : Swift.Equatable {}
extension ASAPPSDK.ImageFormat : Swift.Hashable {}
extension ASAPPSDK.CacheType : Swift.Equatable {}
extension ASAPPSDK.CacheType : Swift.Hashable {}
extension ASAPPSDK.ContentMode : Swift.Equatable {}
extension ASAPPSDK.ContentMode : Swift.Hashable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ASAPPSDK.KFAnimatedImageViewRepresenter : SwiftUI.UIViewRepresentable {}
